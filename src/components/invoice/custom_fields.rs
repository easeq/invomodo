use leptos::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use time::{Date, Duration, OffsetDateTime};

use crate::components::editable_grid::{
    FormData, FormValidation, ItemData, ValidationResult, use_editable_grid, validation::validators,
};

// Enhanced enums and structures
#[derive(Clone, PartialEq, Debug, Default, Serialize, Deserialize, Hash, Eq)]
pub enum FieldCategory {
    #[default]
    Invoice,
    Biller,
    Client,
    LineItem,
    ExtraInfo,
}

impl std::fmt::Display for FieldCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FieldCategory::Biller => write!(f, "Biller"),
            FieldCategory::Client => write!(f, "Client"),
            FieldCategory::LineItem => write!(f, "LineItem"),
            FieldCategory::Invoice => write!(f, "Invoice"),
            FieldCategory::ExtraInfo => write!(f, "ExtraInfo"),
        }
    }
}

#[derive(Clone, PartialEq, Debug, Default, Serialize, Deserialize)]
pub enum FieldType {
    #[default]
    Text,
    Number,
    Email,
    Phone,
    Dropdown,
    Date,
    Checkbox,
    Textarea,
    AutoGenerated,
}

impl FieldType {
    pub fn to_input_type(&self) -> &'static str {
        match self {
            FieldType::Number => "number",
            FieldType::Email => "email",
            FieldType::Date => "date",
            _ => "text",
        }
    }
}

impl std::fmt::Display for FieldType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FieldType::Text => write!(f, "Text"),
            FieldType::Number => write!(f, "Number"),
            FieldType::Email => write!(f, "Email"),
            FieldType::Phone => write!(f, "Phone"),
            FieldType::Dropdown => write!(f, "Dropdown"),
            FieldType::Date => write!(f, "Date"),
            FieldType::Checkbox => write!(f, "Checkbox"),
            FieldType::Textarea => write!(f, "Textarea"),
            FieldType::AutoGenerated => write!(f, "Auto Generated"),
        }
    }
}

// Field grouping and layout
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum FieldGroupLayout {
    Horizontal,              // Fields display on same row
    Vertical,                // Fields display in column
    Grid { columns: usize }, // Custom grid layout
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct FieldGroup {
    pub id: String,
    pub name: String,
    pub layout: FieldGroupLayout,
    pub field_ids: Vec<String>,
    pub is_repeatable: bool, // For array-like fields (e.g., address lines)
    pub max_repetitions: Option<usize>,
}

// Auto-generation configuration
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum AutoGenerationRule {
    Counter {
        prefix: Option<String>,
        suffix: Option<String>,
        start_value: i64,
        increment: i64,
        reset_period: Option<ResetPeriod>,
        padding: Option<usize>, // Zero-padding for numbers
    },
    Formula {
        expression: String,        // Custom formula expression
        dependencies: Vec<String>, // Field IDs this depends on
    },
    Timestamp {
        format: String,
        offset_days: Option<i64>,
    },
    Custom {
        generator_id: String, // Reference to custom generator
        parameters: HashMap<String, String>,
    },
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum ResetPeriod {
    Daily,
    Monthly,
    Yearly,
    Never,
}

// Date default configuration
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum DateDefault {
    Today,
    TodayPlus { days: i64 },
    TodayMinus { days: i64 },
    StartOfMonth,
    EndOfMonth,
    StartOfYear,
    EndOfYear,
    Custom { date: String }, // ISO date string
    None,
}

// Option configuration for dropdowns
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct FieldOption {
    pub label: String,
    pub value: String,
    pub is_default: bool,
}

// Field permissions and system configuration
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct FieldPermissions {
    pub is_system: bool,   // System/built-in field
    pub is_internal: bool, // Internal use only
    pub can_edit: bool,    // Can be modified
    pub can_delete: bool,  // Can be deleted
    pub can_disable: bool, // Can be hidden/disabled
}

impl Default for FieldPermissions {
    fn default() -> Self {
        Self {
            is_system: false,
            is_internal: false,
            can_edit: true,
            can_delete: true,
            can_disable: true,
        }
    }
}

// Enhanced field value types
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum FieldValue {
    Text(String),
    Number(f64),
    Email(String),
    Phone(String),
    Dropdown(String),
    Date(String),
    Checkbox(bool),
    Textarea(String),
    AutoGenerated(String),
    Array(Vec<String>), // For repeatable fields
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct FieldItemValue {
    pub id: String,
    pub label: String,
    pub value: FieldValue,
}

// Enhanced FieldItem structure
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct FieldItem {
    pub id: String,
    pub name: String,
    pub field_type: FieldType,
    pub category: FieldCategory,
    pub default_value: String,
    pub required: bool,
    pub permissions: FieldPermissions,

    // Enhanced options
    pub options: Vec<FieldOption>, // Replaced simple string with structured options
    pub default_checked: bool,

    // Grouping and layout
    pub group_id: Option<String>,
    pub order_in_group: Option<i32>,

    // Auto-generation
    pub auto_generation: Option<AutoGenerationRule>,

    // Date-specific defaults
    pub date_default: Option<DateDefault>,

    // Validation
    pub min_length: Option<usize>,
    pub max_length: Option<usize>,
    pub pattern: Option<String>, // Regex pattern for validation

    // Display and behavior
    pub placeholder: Option<String>,
    pub help_text: Option<String>,
    pub is_hidden: bool,
    pub is_readonly: bool,
}

impl Hash for FieldItem {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}

impl PartialEq for FieldItem {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl Eq for FieldItem {}

// Enhanced form structure
#[derive(Default, Clone, PartialEq, Debug)]
pub struct FieldForm {
    pub name: String,
    pub field_type: FieldType,
    pub category: FieldCategory,
    pub default_value: String,
    pub required: bool,
    pub permissions: FieldPermissions,
    pub options: Vec<FieldOption>,
    pub default_checked: bool,
    pub group_id: Option<String>,
    pub order_in_group: Option<i32>,
    pub auto_generation: Option<AutoGenerationRule>,
    pub date_default: Option<DateDefault>,
    pub min_length: Option<usize>,
    pub max_length: Option<usize>,
    pub pattern: Option<String>,
    pub placeholder: Option<String>,
    pub help_text: Option<String>,
    pub is_hidden: bool,
    pub is_readonly: bool,
}

// Auto-generation trait for custom generators
pub trait AutoValueGenerator {
    fn generate(
        &self,
        parameters: &HashMap<String, String>,
        context: &GenerationContext,
    ) -> Result<String, String>;
    fn get_id(&self) -> &str;
    fn get_name(&self) -> &str;
    fn get_description(&self) -> &str;
}

#[derive(Clone, Debug)]
pub struct GenerationContext {
    pub current_values: HashMap<String, FieldValue>,
    pub counter_states: HashMap<String, i64>,
    pub current_date: OffsetDateTime,
}

// Utility functions for auto-generation
impl AutoGenerationRule {
    pub fn generate(&self, context: &GenerationContext, field_id: &str) -> Result<String, String> {
        match self {
            AutoGenerationRule::Counter {
                prefix,
                suffix,
                start_value,
                increment,
                reset_period,
                padding,
            } => {
                let current_count = context.counter_states.get(field_id).unwrap_or(start_value);
                let formatted_number = if let Some(pad) = padding {
                    format!("{:0width$}", current_count, width = pad)
                } else {
                    current_count.to_string()
                };

                let mut result = String::new();
                if let Some(p) = prefix {
                    result.push_str(p);
                }
                result.push_str(&formatted_number);
                if let Some(s) = suffix {
                    result.push_str(s);
                }

                Ok(result)
            }
            AutoGenerationRule::Timestamp {
                format,
                offset_days,
            } => {
                let mut target_date = context.current_date;
                if let Some(days) = offset_days {
                    target_date += Duration::days(*days);
                }

                // Simple format handling - extend as needed
                let formatted = match format.as_str() {
                    "YYYY-MM-DD" => target_date.date().to_string(),
                    "YYYYMMDD" => target_date
                        .format(&time::format_description::parse("[year][month][day]").unwrap())
                        .unwrap(),
                    _ => target_date.date().to_string(),
                };

                Ok(formatted)
            }
            AutoGenerationRule::Formula {
                expression,
                dependencies,
            } => {
                // Placeholder for formula evaluation - implement based on your needs
                Ok(format!("FORMULA({})", expression))
            }
            AutoGenerationRule::Custom {
                generator_id,
                parameters,
            } => {
                // Placeholder for custom generator lookup
                Ok(format!("CUSTOM({})", generator_id))
            }
        }
    }
}

impl DateDefault {
    pub fn resolve(&self) -> Result<String, String> {
        let today = OffsetDateTime::now_utc().date();

        match self {
            DateDefault::Today => Ok(today.to_string()),
            DateDefault::TodayPlus { days } => {
                let target = today + Duration::days(*days);
                Ok(target.to_string())
            }
            DateDefault::TodayMinus { days } => {
                let target = today - Duration::days(*days);
                Ok(target.to_string())
            }
            DateDefault::StartOfMonth => {
                let start = Date::from_calendar_date(today.year(), today.month(), 1)
                    .map_err(|e| format!("Date error: {}", e))?;
                Ok(start.to_string())
            }
            DateDefault::EndOfMonth => {
                let next_month = if today.month() == time::Month::December {
                    Date::from_calendar_date(today.year() + 1, time::Month::January, 1)
                } else {
                    Date::from_calendar_date(today.year(), today.month().next(), 1)
                }
                .map_err(|e| format!("Date error: {}", e))?;

                let end = next_month - Duration::days(1);
                Ok(end.to_string())
            }
            DateDefault::StartOfYear => {
                let start = Date::from_calendar_date(today.year(), time::Month::January, 1)
                    .map_err(|e| format!("Date error: {}", e))?;
                Ok(start.to_string())
            }
            DateDefault::EndOfYear => {
                let end = Date::from_calendar_date(today.year(), time::Month::December, 31)
                    .map_err(|e| format!("Date error: {}", e))?;
                Ok(end.to_string())
            }
            DateDefault::Custom { date } => Ok(date.clone()),
            DateDefault::None => Ok(String::new()),
        }
    }
}

// Implement required traits
impl FormData for FieldItem {
    type FormProps = FieldForm;

    fn default() -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            name: String::new(),
            field_type: FieldType::default(),
            category: FieldCategory::default(),
            default_value: String::new(),
            required: false,
            permissions: FieldPermissions::default(),
            options: vec![],
            default_checked: false,
            group_id: None,
            order_in_group: None,
            auto_generation: None,
            date_default: None,
            min_length: None,
            max_length: None,
            pattern: None,
            placeholder: None,
            help_text: None,
            is_hidden: false,
            is_readonly: false,
        }
    }

    fn to_form_props(&self) -> Self::FormProps {
        FieldForm {
            name: self.name.clone(),
            field_type: self.field_type.clone(),
            category: self.category.clone(),
            default_value: self.default_value.clone(),
            required: self.required,
            permissions: self.permissions.clone(),
            options: self.options.clone(),
            default_checked: self.default_checked,
            group_id: self.group_id.clone(),
            order_in_group: self.order_in_group,
            auto_generation: self.auto_generation.clone(),
            date_default: self.date_default.clone(),
            min_length: self.min_length,
            max_length: self.max_length,
            pattern: self.pattern.clone(),
            placeholder: self.placeholder.clone(),
            help_text: self.help_text.clone(),
            is_hidden: self.is_hidden,
            is_readonly: self.is_readonly,
        }
    }

    fn from_form_props(props: &Self::FormProps) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            name: props.name.clone(),
            field_type: props.field_type.clone(),
            category: props.category.clone(),
            default_value: props.default_value.clone(),
            required: props.required,
            permissions: props.permissions.clone(),
            options: props.options.clone(),
            default_checked: props.default_checked,
            group_id: props.group_id.clone(),
            order_in_group: props.order_in_group,
            auto_generation: props.auto_generation.clone(),
            date_default: props.date_default.clone(),
            min_length: props.min_length,
            max_length: props.max_length,
            pattern: props.pattern.clone(),
            placeholder: props.placeholder.clone(),
            help_text: props.help_text.clone(),
            is_hidden: props.is_hidden,
            is_readonly: props.is_readonly,
        }
    }
}

impl ItemData for FieldItem {
    fn get_id(&self) -> String {
        self.id.clone()
    }

    fn get_title(&self) -> String {
        self.name.clone()
    }

    fn get_subtitle(&self) -> Option<String> {
        match self.field_type {
            FieldType::Checkbox => {
                if self.default_checked {
                    Some("Checked by default".to_string())
                } else {
                    Some("Unchecked by default".to_string())
                }
            }
            FieldType::Dropdown => {
                let options_str = self
                    .options
                    .iter()
                    .map(|opt| opt.label.clone())
                    .collect::<Vec<_>>()
                    .join(", ");
                Some(format!("Options: {}", options_str))
            }
            FieldType::Date => {
                if let Some(ref date_default) = self.date_default {
                    match date_default.resolve() {
                        Ok(resolved) => Some(format!("Default: {}", resolved)),
                        Err(_) => Some(self.default_value.clone()),
                    }
                } else {
                    Some(self.default_value.clone())
                }
            }
            FieldType::AutoGenerated => {
                if let Some(ref auto_gen) = self.auto_generation {
                    match auto_gen {
                        AutoGenerationRule::Counter { prefix, suffix, .. } => Some(format!(
                            "Auto: {}{}{}",
                            prefix.as_deref().unwrap_or(""),
                            "###",
                            suffix.as_deref().unwrap_or("")
                        )),
                        _ => Some("Auto-generated".to_string()),
                    }
                } else {
                    Some("Auto-generated".to_string())
                }
            }
            _ => Some(self.default_value.clone()),
        }
    }

    fn get_metadata(&self) -> Vec<(String, String)> {
        let mut metadata = vec![
            ("field_type".to_string(), self.field_type.to_string()),
            ("category".to_string(), self.category.to_string()),
            ("required".to_string(), self.required.to_string()),
        ];

        if self.permissions.is_system {
            metadata.push(("system".to_string(), "true".to_string()));
        }
        if self.permissions.is_internal {
            metadata.push(("internal".to_string(), "true".to_string()));
        }
        if let Some(ref group_id) = self.group_id {
            metadata.push(("group".to_string(), group_id.clone()));
        }

        metadata
    }
}

impl FormValidation for FieldForm {
    fn validate(&self) -> ValidationResult {
        let mut results = vec![
            validators::required(&self.name, "Field Name"),
            validators::min_length(&self.name, 2, "Field Name"),
            validators::max_length(&self.name, 50, "Field Name"),
        ];

        // Validate dropdown options
        if self.field_type == FieldType::Dropdown && self.options.is_empty() {
            results.push(ValidationResult {
                is_valid: false,
                errors: vec!["Dropdown fields must have at least one option".to_string()],
                ..Default::default()
            });
        }

        // Validate auto-generation configuration
        if self.field_type == FieldType::AutoGenerated && self.auto_generation.is_none() {
            results.push(ValidationResult {
                is_valid: false,
                errors: vec!["Auto-generated fields must have generation rules".to_string()],
                ..Default::default()
            });
        }

        validators::combine_results(results)
    }
}

// Enhanced component with all new features
#[component]
pub fn Fields(
    state: RwSignal<Vec<FieldItem>>,
    #[prop(optional)] groups: Option<RwSignal<Vec<FieldGroup>>>,
) -> impl IntoView {
    let form_ref: NodeRef<leptos::html::Form> = NodeRef::new();
    let grid = use_editable_grid(state.read_only(), state.write_only(), form_ref);

    // All the existing form signals plus new ones
    let (name_value, set_name_value) = signal(String::new());
    let (field_type_value, set_field_type_value) = signal(FieldType::Text);
    let (category_value, set_category_value) = signal(FieldCategory::Invoice);
    let (default_value, set_default_value) = signal(String::new());
    let (required_value, set_required_value) = signal(false);
    let (options_value, set_options_value) = signal(Vec::<FieldOption>::new());
    let (default_checked, set_default_checked) = signal(false);
    let (group_id_value, set_group_id_value) = signal(None::<String>);
    let (auto_generation_value, set_auto_generation_value) = signal(None::<AutoGenerationRule>);
    let (date_default_value, set_date_default_value) = signal(None::<DateDefault>);
    let (placeholder_value, set_placeholder_value) = signal(None::<String>);
    let (help_text_value, set_help_text_value) = signal(None::<String>);
    let (is_readonly_value, set_is_readonly_value) = signal(false);

    // Update form fields when grid state changes
    Effect::new(move |_| {
        let form_state = grid.form_state.get();
        let form = form_state.current_form;
        set_name_value.set(form.name);
        set_field_type_value.set(form.field_type);
        set_category_value.set(form.category);
        set_default_value.set(form.default_value);
        set_required_value.set(form.required);
        set_options_value.set(form.options);
        set_default_checked.set(form.default_checked);
        set_group_id_value.set(form.group_id);
        set_auto_generation_value.set(form.auto_generation);
        set_date_default_value.set(form.date_default);
        set_placeholder_value.set(form.placeholder);
        set_help_text_value.set(form.help_text);
        set_is_readonly_value.set(form.is_readonly);
    });

    // Handle form submission
    let handle_submit = move |ev: web_sys::SubmitEvent| {
        ev.prevent_default();

        let form_data = FieldForm {
            name: name_value.get(),
            field_type: field_type_value.get(),
            category: category_value.get(),
            default_value: default_value.get(),
            required: required_value.get(),
            permissions: FieldPermissions::default(),
            options: options_value.get(),
            default_checked: default_checked.get(),
            group_id: group_id_value.get(),
            order_in_group: None,
            auto_generation: auto_generation_value.get(),
            date_default: date_default_value.get(),
            min_length: None,
            max_length: None,
            pattern: None,
            placeholder: placeholder_value.get(),
            help_text: help_text_value.get(),
            is_hidden: false,
            is_readonly: is_readonly_value.get(),
        };

        let validation = form_data.validate();
        if validation.is_valid {
            grid.actions.submit_form.run(form_data);
            // Reset form
            set_name_value.set(String::new());
            set_field_type_value.set(FieldType::Text);
            set_category_value.set(FieldCategory::Invoice);
            set_default_value.set(String::new());
            set_required_value.set(false);
            set_options_value.set(vec![]);
            set_default_checked.set(false);
            set_group_id_value.set(None);
            set_auto_generation_value.set(None);
            set_date_default_value.set(None);
            set_placeholder_value.set(None);
            set_help_text_value.set(None);
            set_is_readonly_value.set(false);
        }
    };

    view! {
        <div class="w-full px-4 py-6">
            // Enhanced form with all new features
            <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                <h3 class="text-lg font-medium leading-6 text-gray-900 mb-6">
                    {move || {
                        let form_state = grid.form_state.get();
                        if form_state.is_editing {
                            "Edit Custom Field"
                        } else {
                            "Add New Custom Field"
                        }
                    }}
                </h3>

                <form node_ref=form_ref on:submit=handle_submit>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        // Basic field information
                        <div>
                            <label class="form-label" for="field-name">
                                "Field Name"
                            </label>
                            <input
                                class="form-input"
                                id="field-name"
                                type="text"
                                prop:value=move || name_value.get()
                                on:input=move |ev| set_name_value.set(event_target_value(&ev))
                                required
                            />
                        </div>

                        <div>
                            <label class="form-label" for="field-type">
                                "Field Type"
                            </label>
                            <select
                                class="form-select"
                                id="field-type"
                                prop:value=move || field_type_value.get().to_string()
                                on:change=move |ev| {
                                    let value = event_target_value(&ev);
                                    let field_type = match value.as_str() {
                                        "Number" => FieldType::Number,
                                        "Email" => FieldType::Email,
                                        "Phone" => FieldType::Phone,
                                        "Dropdown" => FieldType::Dropdown,
                                        "Date" => FieldType::Date,
                                        "Checkbox" => FieldType::Checkbox,
                                        "Textarea" => FieldType::Textarea,
                                        "AutoGenerated" => FieldType::AutoGenerated,
                                        _ => FieldType::Text,
                                    };
                                    set_field_type_value.set(field_type);
                                }
                            >
                                <option value="Text">"Text"</option>
                                <option value="Number">"Number"</option>
                                <option value="Email">"Email"</option>
                                <option value="Phone">"Phone"</option>
                                <option value="Dropdown">"Dropdown"</option>
                                <option value="Date">"Date"</option>
                                <option value="Checkbox">"Checkbox"</option>
                                <option value="Textarea">"Textarea"</option>
                                <option value="AutoGenerated">"Auto Generated"</option>
                            </select>
                        </div>

                        <div>
                            <label class="form-label" for="category">
                                "Category"
                            </label>
                            <select
                                class="form-select"
                                id="category"
                                prop:value=move || category_value.get().to_string()
                                on:change=move |ev| {
                                    let value = event_target_value(&ev);
                                    let category = match value.as_str() {
                                        "Biller" => FieldCategory::Biller,
                                        "Client" => FieldCategory::Client,
                                        "LineItem" => FieldCategory::LineItem,
                                        "ExtraInfo" => FieldCategory::ExtraInfo,
                                        _ => FieldCategory::Invoice,
                                    };
                                    set_category_value.set(category);
                                }
                            >
                                <option value="Invoice">"Global Invoice"</option>
                                <option value="Biller">"Biller Address"</option>
                                <option value="Client">"Client Address"</option>
                                <option value="LineItem">"Line Item"</option>
                                <option value="ExtraInfo">"Billing Details"</option>
                            </select>
                        </div>

                        // Conditional fields based on type
                        {move || {
                            match field_type_value.get() {
                                FieldType::Date => {
                                    view! {
                                        <div>
                                            <label class="form-label" for="date-default">
                                                "Date Default"
                                            </label>
                                            <select
                                                class="form-select"
                                                id="date-default"
                                                on:change=move |ev| {
                                                    let value = event_target_value(&ev);
                                                    let default = match value.as_str() {
                                                        "today" => Some(DateDefault::Today),
                                                        "today_plus_30" => Some(DateDefault::TodayPlus { days: 30 }),
                                                        "start_of_month" => Some(DateDefault::StartOfMonth),
                                                        "end_of_month" => Some(DateDefault::EndOfMonth),
                                                        _ => None,
                                                    };
                                                    set_date_default_value.set(default);
                                                }
                                            >
                                                <option value="">"No default"</option>
                                                <option value="today">"Today"</option>
                                                <option value="today_plus_30">"Today + 30 days"</option>
                                                <option value="start_of_month">"Start of month"</option>
                                                <option value="end_of_month">"End of month"</option>
                                            </select>
                                        </div>
                                    }
                                        .into_any()
                                }
                                _ => view! { <div></div> }.into_any(),
                            }
                        }}

                        // Additional configuration options
                        <div>
                            <label class="form-label" for="placeholder">
                                "Placeholder"
                            </label>
                            <input
                                class="form-input"
                                id="placeholder"
                                type="text"
                                prop:value=move || placeholder_value.get().unwrap_or_default()
                                on:input=move |ev| {
                                    let value = event_target_value(&ev);
                                    set_placeholder_value
                                        .set(if value.is_empty() { None } else { Some(value) });
                                }
                            />
                        </div>

                        <div class="flex items-end space-x-4">
                            <label class="form-checkbox-label">
                                <input
                                    type="checkbox"
                                    class="form-checkbox"
                                    prop:checked=move || required_value.get()
                                    on:change=move |ev| {
                                        set_required_value.set(event_target_checked(&ev))
                                    }
                                />
                                <span class="ml-2 text-sm text-gray-700">"Required"</span>
                            </label>

                            <label class="form-checkbox-label">
                                <input
                                    type="checkbox"
                                    class="form-checkbox"
                                    prop:checked=move || is_readonly_value.get()
                                    on:change=move |ev| {
                                        set_is_readonly_value.set(event_target_checked(&ev))
                                    }
                                />
                                <span class="ml-2 text-sm text-gray-700">"Read Only"</span>
                            </label>
                        </div>
                    </div>

                    // Submit buttons
                    <div class="mt-6 flex justify-end gap-3">
                        <Show when=move || grid.form_state.get().is_editing>
                            <button
                                class="inline-flex justify-center rounded-md border border-gray-300 bg-white py-2 px-4 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50"
                                type="button"
                                on:click=move |_| grid.actions.cancel_edit.run(())
                            >
                                "Cancel"
                            </button>
                        </Show>
                        <button
                            class="inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700"
                            type="submit"
                        >
                            {move || {
                                let form_state = grid.form_state.get();
                                if form_state.is_editing { "Update Field" } else { "Add Field" }
                            }}
                        </button>
                    </div>
                </form>
            </div>

            // Enhanced table with system field indicators
            <div class="mt-8 bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
                {move || {
                    if grid.device_type.get().is_mobile() {
                        // Mobile card layout
                        view! {
                            <div class="p-4 space-y-4">
                                <For
                                    each=move || grid.items.get()
                                    key=|item_state| item_state.data.id.clone()
                                    children=move |item_state| {
                                        let index = item_state.index;
                                        let item = item_state.data.clone();
                                        let can_edit = item.permissions.can_edit;
                                        let can_delete = item.permissions.can_delete;
                                        let is_system = item.permissions.is_system;

                                        view! {
                                            <div class="border rounded-lg p-4 bg-gray-50">
                                                <div class="flex justify-between items-start mb-2">
                                                    <div>
                                                        <div class="flex items-center gap-2">
                                                            <h3 class="font-semibold text-lg">{item.name.clone()}</h3>
                                                            {if is_system {
                                                                Some(
                                                                    view! {
                                                                        <span class="px-1 py-0.5 text-xs bg-gray-200 text-gray-700 rounded">
                                                                            "SYSTEM"
                                                                        </span>
                                                                    },
                                                                )
                                                            } else {
                                                                None
                                                            }}
                                                        </div>
                                                        <p class="text-gray-500 text-sm">
                                                            {item.category.to_string()}
                                                        </p>
                                                    </div>
                                                    <span class="px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded">
                                                        {item.field_type.to_string()}
                                                    </span>
                                                </div>

                                                {item
                                                    .help_text
                                                    .map(|help| {
                                                        view! { <p class="text-sm text-gray-600 mb-2">{help}</p> }
                                                    })}

                                                <div class="flex justify-between items-center mt-3 text-sm text-gray-600">
                                                    <div class="space-y-1">
                                                        <span>
                                                            "Required: " {if item.required { "Yes" } else { "No" }}
                                                        </span>
                                                        {if item.is_readonly {
                                                            Some(view! { <div>"Read Only: Yes"</div> })
                                                        } else {
                                                            None
                                                        }}
                                                    </div>
                                                    <div class="flex space-x-2">
                                                        {if can_edit {
                                                            Some(
                                                                view! {
                                                                    <button
                                                                        class="px-3 py-1 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700"
                                                                        on:click=move |_| grid.actions.edit_item.run(index)
                                                                    >
                                                                        "Edit"
                                                                    </button>
                                                                },
                                                            )
                                                        } else {
                                                            None
                                                        }}
                                                        {if can_delete {
                                                            Some(
                                                                view! {
                                                                    <button
                                                                        class="px-3 py-1 text-sm bg-red-600 text-white rounded hover:bg-red-700"
                                                                        on:click=move |_| grid.actions.delete_item.run(index)
                                                                    >
                                                                        "Delete"
                                                                    </button>
                                                                },
                                                            )
                                                        } else {
                                                            None
                                                        }}
                                                    </div>
                                                </div>
                                            </div>
                                        }
                                    }
                                />
                            </div>
                        }
                            .into_any()
                    } else {
                        // Desktop table layout
                        view! {
                            <div class="overflow-x-auto">
                                <table class="min-w-full divide-y divide-gray-200">
                                    <thead class="bg-gray-50">
                                        <tr>
                                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                "Field Name"
                                            </th>
                                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                "Type"
                                            </th>
                                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                "Category"
                                            </th>
                                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                "Default"
                                            </th>
                                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                                "Settings"
                                            </th>
                                            <th class="relative px-6 py-3">"Actions"</th>
                                        </tr>
                                    </thead>
                                    <tbody class="bg-white divide-y divide-gray-200">
                                        <For
                                            each=move || grid.items.get()
                                            key=|item_state| item_state.data.id.clone()
                                            children=move |item_state| {
                                                let index = item_state.index;
                                                let item = item_state.data.clone();
                                                let can_edit = item.permissions.can_edit;
                                                let can_delete = item.permissions.can_delete;
                                                let is_system = item.permissions.is_system;

                                                view! {
                                                    <tr>
                                                        <td class="px-6 py-4 whitespace-nowrap">
                                                            <div class="flex items-center">
                                                                <div class="text-sm font-medium text-gray-900">
                                                                    {item.name.clone()}
                                                                </div>
                                                                {if is_system {
                                                                    Some(
                                                                        view! {
                                                                            <span class="ml-2 px-2 py-1 text-xs bg-gray-200 text-gray-700 rounded">
                                                                                "SYSTEM"
                                                                            </span>
                                                                        },
                                                                    )
                                                                } else {
                                                                    None
                                                                }}
                                                            </div>
                                                            {item
                                                                .help_text
                                                                .clone()
                                                                .map(|help| {
                                                                    view! { <div class="text-sm text-gray-500">{help}</div> }
                                                                })}
                                                        </td>
                                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                                            {item.field_type.to_string()}
                                                        </td>
                                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                                            {item.category.to_string()}
                                                        </td>
                                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                                            {item.get_subtitle().unwrap_or_default()}
                                                        </td>
                                                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                                            <div class="space-y-1">
                                                                {if item.required {
                                                                    Some(view! { <div class="text-red-600">"Required"</div> })
                                                                } else {
                                                                    None
                                                                }}
                                                                {if item.is_readonly {
                                                                    Some(
                                                                        view! { <div class="text-orange-600">"Read Only"</div> },
                                                                    )
                                                                } else {
                                                                    None
                                                                }}
                                                            </div>
                                                        </td>
                                                        <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                                            <div class="flex justify-end space-x-2">
                                                                {if can_edit {
                                                                    Some(
                                                                        view! {
                                                                            <button
                                                                                class="text-indigo-600 hover:text-indigo-900"
                                                                                on:click=move |_| grid.actions.edit_item.run(index)
                                                                            >
                                                                                "Edit"
                                                                            </button>
                                                                        },
                                                                    )
                                                                } else {
                                                                    None
                                                                }}
                                                                {if can_delete {
                                                                    Some(
                                                                        view! {
                                                                            <button
                                                                                class="text-red-600 hover:text-red-900"
                                                                                on:click=move |_| grid.actions.delete_item.run(index)
                                                                            >
                                                                                "Delete"
                                                                            </button>
                                                                        },
                                                                    )
                                                                } else {
                                                                    None
                                                                }}
                                                            </div>
                                                        </td>
                                                    </tr>
                                                }
                                            }
                                        />
                                    </tbody>
                                </table>
                            </div>
                        }
                            .into_any()
                    }
                }}
            </div>

            // Stats section with enhanced info
            <div class="mt-6 bg-gray-50 p-4 rounded-lg">
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm text-gray-600">
                    <div>
                        <span class="font-medium">"Total Fields: "</span>
                        {move || grid.item_count.get()}
                    </div>
                    <div>
                        <span class="font-medium">"System Fields: "</span>
                        {move || {
                            grid.items
                                .get()
                                .iter()
                                .filter(|item| item.data.permissions.is_system)
                                .count()
                        }}
                    </div>
                    <div>
                        <span class="font-medium">"Required Fields: "</span>
                        {move || {
                            grid.items.get().iter().filter(|item| item.data.required).count()
                        }}
                    </div>
                    <div>
                        <span class="font-medium">"Device: "</span>
                        {move || format!("{:?}", grid.device_type.get())}
                    </div>
                </div>
            </div>
        </div>
    }
}
